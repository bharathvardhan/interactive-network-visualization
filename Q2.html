<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <title>Q2 Force-Directed Graph</title>
  <style>
    path.link {
      fill: none;
    }

    /* value == 0 (similar): gray, thick, solid */
    path.link.similar {
      stroke: #666;
      stroke-width: 3px;
      stroke-dasharray: none;
    }

    /* value == 1 (not similar): green, thin, dashed */
    path.link.not-similar {
      stroke: green;
      stroke-width: 1px;
      stroke-dasharray: 5, 5;
    }

    circle {
      stroke: black;
      stroke-width: 1.5px;
    }

    /* labels: top-right of node, bold */
    .node text.label {
      fill: #000;
      font: 10px sans-serif;
      font-weight: bold;
      pointer-events: none;
    }

    /* username text in top-right */
    text#credit {
      font: 14px sans-serif;
      fill: #000;
    }
  </style>
</head>

<body>
  <script type="text/javascript" src="../lib/d3.v5.min.js"></script>
  <script>
    d3.dsv(",", "board_games.csv", function (d) {
      return {
        source: d.source,
        target: d.target,
        value: +d.value,
      };
    })
      .then(function (data) {
        var links = data;
        var nodes = {};

        // compute the distinct nodes from the links.
        links.forEach(function (link) {
          link.source =
            nodes[link.source] ||
            (nodes[link.source] = { name: link.source });
          link.target =
            nodes[link.target] ||
            (nodes[link.target] = { name: link.target });
        });

        // compute node degree (D3 v5 does not support d.weight)
        links.forEach(function (link) {
          link.source.degree = (link.source.degree || 0) + 1;
          link.target.degree = (link.target.degree || 0) + 1;
        });

        var nodeList = d3.values(nodes);
        var minDegree = d3.min(nodeList, function (n) {
          return n.degree;
        });
        var maxDegree = d3.max(nodeList, function (n) {
          return n.degree;
        });

        // radius scaling by degree (avoid extreme sizes)
        var radiusScale = d3
          .scaleSqrt()
          .domain([minDegree, maxDegree])
          .range([8, 22]);

        // color gradient by degree (higher degree = darker)
        var colorScale = d3
          .scaleSequential(d3.interpolateBlues)
          .domain([maxDegree, minDegree]); // reversed so higher is darker

        function getNodeColor(d) {
          if (d.fixed) return "#ffd700"; // pinned nodes: yellow
          return colorScale(d.degree);
        }

        var width = 1200,
          height = 700;

        //DO NOT MODIFY THE BELOW BLOCK OF CODE//
        var force = d3
          .forceSimulation()
          .nodes(d3.values(nodes))
          .force("link", d3.forceLink(links).distance(100))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("x", d3.forceX())
          .force("y", d3.forceY())
          .force("charge", d3.forceManyBody().strength(-250))
          .alphaTarget(1)
          .on("tick", tick);
        //DO NOT MODIFY THE ABOVE BLOCK OF CODE//

        var svg = d3
          .select("body")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        // edges styled by value (0 similar, 1 not similar)
        var path = svg
          .append("g")
          .selectAll("path")
          .data(links)
          .enter()
          .append("path")
          .attr("class", function (d) {
            return "link " + (d.value === 0 ? "similar" : "not-similar");
          });

        // node group (so label + circle move together)
        var node = svg
          .selectAll(".node")
          .data(force.nodes())
          .enter()
          .append("g")
          .attr("class", "node")
          .call(
            d3
              .drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended)
          )
          .on("dblclick", dblclicked);


        node
          .append("circle")
          .attr("id", function (d) {
            return d.name.replace(/\s+/g, "").toLowerCase();
          })
          .attr("r", function (d) {
            return radiusScale(d.degree);
          })
          .attr("fill", function (d) {
            return getNodeColor(d);
          });


        node
          .append("text")
          .attr("class", "label")
          .attr("text-anchor", "start")
          .attr("x", function (d) {
            return radiusScale(d.degree) + 4;
          })
          .attr("dy", "-0.35em")
          .text(function (d) {
            return d.name;
          });

        svg
          .append("text")
          .attr("id", "credit")
          .attr("x", width - 10)
          .attr("y", 20)
          .attr("text-anchor", "end")
          .text("bharathvardhanreddy"); 

        // draw curvy links + move nodes
        function tick() {
          path.attr("d", function (d) {
            var dx = d.target.x - d.source.x,
              dy = d.target.y - d.source.y,
              dr = Math.sqrt(dx * dx + dy * dy);
            return (
              "M" +
              d.source.x +
              "," +
              d.source.y +
              "A" +
              dr +
              "," +
              dr +
              " 0 0,1 " +
              d.target.x +
              "," +
              d.target.y
            );
          });

          node.attr("transform", function (d) {
            return "translate(" + d.x + "," + d.y + ")";
          });
        }

        // pin on drag end
        function dragstarted(d) {
          if (!d3.event.active) force.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }

        function dragged(d) {
          d.fx = d3.event.x;
          d.fy = d3.event.y;
        }

        function dragended(d) {
          if (!d3.event.active) force.alphaTarget(0);
          d.fixed = true; // mark pinned
          d.fx = d.x;
          d.fy = d.y;

          // update colors so pinned nodes become yellow
          node.select("circle").attr("fill", function (n) {
            return getNodeColor(n);
          });
        }

        // dblclick unpins
        function dblclicked(d) {
          if (d.fixed) {
            d.fixed = false;
            d.fx = null;
            d.fy = null;

            node.select("circle").attr("fill", function (n) {
              return getNodeColor(n);
            });
          }
        }
      })
      .catch(function (error) {
        console.log(error);
      });
  </script>
</body>
</html>